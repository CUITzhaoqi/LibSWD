<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Serial Wire Debug Open Library: Serial Wire Debug Open Library.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Serial Wire Debug Open Library. </h1>  </div>
</div>
<div class="contents">
<h3 class="version">libswd-0.1 </h3><h2><a class="anchor" id="doc_introduction"></a>
Introduction</h2>
<p>LibSWD is an Open-Source framework to deal with with Serial Wire Debug Port in accordance to ADI (Arm Debug Interface, version 5.0 at the moment) specification. It is released under 3-clause BSD license. For more information please visit project website at <a href="http://libswd.sf.net">http://libswd.sf.net</a> </p>
<h2><a class="anchor" id="doc_brief"></a>
What is this about</h2>
<p>Serial Wire Debug is an alternative to JTAG (IEEE1149.1) transport layer for accessing the Debug Access Port in ARM-Cortex based devices. LibSWD provides methods for bitstream generation on the wire using simple but flexible API that can reuse capabilities of existing applications for easier integration. Every bus operation such as control, request, turnaround, acknowledge, data and parity packet is named a "command" represented by a <a class="el" href="structswd__cmd__t.html" title="SWD Command Element Structure.">swd_cmd_t</a> data type that builds up the queue that later can be flushed into real hardware using standard set of (application-specific) driver functions. This way LibSWD is almost standalone and can be easily integrated into existing utilities for low-level access and only requires in return to define driver bridge that controls the physical interface interconnecting host and target. Drivers and other application-specific functions are "extern" and located in external file crafted for that application and its hardware. LibSWD is therefore best way to make your application SWD aware.</p>
<h2><a class="anchor" id="doc_details"></a>
How it works</h2>
<h3><a class="anchor" id="doc_context"></a>
SWD Context</h3>
<p>The most important data type in LibSWD is <a class="el" href="structswd__ctx__t.html" title="SWD Context Structure definition.">swd_ctx_t</a> structure, a context that represents logical entity of the swd bus (transport layer between host and target) with all its parameters, configuration and command queue. Context is being created with <a class="el" href="libswd_8c.html#ad4f88acc646c06e6e81fbde8117c21af" title="LibSWD initialization routine.">swd_init()</a> function that returns pointer to allocated virgin structure, and it can be destroyed with <a class="el" href="libswd_8c.html#a94b02a9cf4b72e2e76d6a9a34f34f96f" title="De-initialize selected swd context and its command queue.">swd_deinit()</a> function taking the pointer as argument. Context can be set only for one interface-target pair, but there might be many different contexts in use if necessary, so amount of devices in use is not limited.</p>
<h3><a class="anchor" id="doc_functions"></a>
Functions</h3>
<p>All functions in general operates on pointer type and returns number of processed elements on success or negative value with swd_error_code_t on failure. Functions are grouped by functionality that is denoted by function name prefix (ie. swd_bin* are for binary operations, swd_cmdq* deals with command queue, swd_cmd_enqueue* deals with creating commands and attaching them to queue, swd_bus* performs operation on the swd transport system, swd_drv* are the interface drivers, etc).</p>
<p>Standard end-users are encouraged to only use high level functions (swd_bus*, swd_dap*, swd_dp*) to perform operations on the swd transport layer and the target's DAP (Debug Access Port) and its components such as DP (Debug Port) and the AP (Access Port). More advanced users however may use low level functions (swd_cmd*, swd_cmdq*) to group them into new high-level functions that automates some tasks (such as high-level functions does). Functions of type "extern" are the ones to implement in external file by developers that want to incorporate LibSWD into their application. Context structure also has void pointer in the <a class="el" href="structswd__driver__t.html" title="Interface Driver structure.">swd_driver_t</a> structure that can hold address of the external driver structure to be passed into internal swd drivers (extern swd_drv* functions) that wouldn't be accessible otherwise.</p>
<h3><a class="anchor" id="doc_commands"></a>
Commands</h3>
<p>Bus operations are split into "commands" represented by <a class="el" href="structswd__cmd__t.html" title="SWD Command Element Structure.">swd_cmd_t</a> data type. They form a bidirectional command queue that is part of <a class="el" href="structswd__ctx__t.html" title="SWD Context Structure definition.">swd_ctx_t</a> structure. Command type, and so its payload, can be one of: control (user defined 8-bit payload), request (according to the standard), ack, data, parity (data and parity are separate commands!), trn, bitbang and idle (equals to control with zero data). Command type is defined by swd_cmdtype_t and its code can be negative (for MOSI operations) or positive (for MISO operations) - this way bus direction can be easily calculated by multiplying two operation codes (when the result is negative bus will have to change direction), so the libswd "knows" when to put additional TRN command of proper type between enqueued commands.</p>
<p>Payload is stored within union type and its data can be accessed according to payload name, or simply with data8 (char) and data32 (int) fields. Payload for write (MOSI) operations is stored on command creation, but payload for read (MISO) operations becomes available only after command is executed by the interface driver. There are 3 methods of accessing read data - flushing the queue into driver then reading queue directly, single stepping queue execution (flush one-by-one) then reading context log of last executed command results (there are separate fields of type <a class="el" href="structswd__transaction__t.html" title="Most actual SWD bus transaction/packet data.">swd_transaction_t</a> in swd_ctx_t's log structure for read and write operations), or providing a double pointer on command creation to have constant access to its data after execution.</p>
<p>After all commands are enqueued with swd_cmd_enqueue* function set, it is time to send them into physical device with <a class="el" href="libswd_8c.html#ad53379f5a7756cc91b01e867aaaa489d" title="Flush command queue contents into interface driver.">swd_cmdq_flush()</a> funtion. According to the swd_operation_t parameter commands can be flushed one-by-one, all of them, only to the selected command or only after selected command. For low level functions all of these options are available, but for high-level functions only two of them can be used - SWD_OPERATION_ENQUEUE (but not send to the driver) and SWD_OPERATION_EXECUTE (all unexecuted commands on the queue are executed by the driver sequentially) - that makes it possible to perform bus operations one after another having their result just at function return, or compose more advanced sequences leading to preferred result at execution time. Because high-level functions provide simple and elegant manner to get the operation result, it is advised to use them instead dealing with low-level functions (implementing memory management, data allocation and queue operation) that exist only to make high-level functions possible.</p>
<h2><a class="anchor" id="doc_drivers"></a>
Drivers</h2>
<p>Calling the <a class="el" href="libswd_8c.html#ad53379f5a7756cc91b01e867aaaa489d" title="Flush command queue contents into interface driver.">swd_cmdq_flush()</a> function leads to execution of not yet executed commands from the queue (in a manner specified by the operation parameter) on the SWD bus (transport layer between interface and target, not the bus of the target itself) by <a class="el" href="libswd_8c.html#a2891df407bc8178e3ca45bd508822327" title="Transmit selected command from the command queue to the interface driver.">swd_drv_transmit()</a> function that use application specific "extern" functions defined in external file (ie. libswd_urjtag.c) to operate on a real hardware using drivers from existing application. LibSWD use only swd_drv_{mosi,miso}_{8,32} (separate for 8-bit char and 32-bit int data cast type) and swd_drv_{mosi,miso}_trn functions to interact with drivers, so it is possible to easily reuse low-level and high-level devices for communications, as they have all information necessary to perform exact actions - number of bits, payload, command type, shift direction and bus direction. It is even possible to send raw bytes on the bus (control command) or bitbang the bus (bitbang command) if necessary. MOSI (Master Output Slave Input) and MISO (Master Input Slave Output) was used to clearly distinguish transfer direction (from master-interface to target-slave), as opposed to ambiguous read/write statements, so after swd_drv_mosi_trn() master should have its buffers set to output and target inputs active. Drivers, as most of the LibSWD functions, works on data pointers instead data copy and returns number of elements processed (bits in this case) or negative error code on failure.</p>
<h2><a class="anchor" id="doc_example"></a>
Example</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;libswd/libswd.h&gt;</span>
  <span class="keywordtype">int</span> main(){
   <a class="code" href="structswd__ctx__t.html" title="SWD Context Structure definition.">swd_ctx_t</a> *swdctx;
   <span class="keywordtype">int</span> res, *idcode;
   swdctx=<a class="code" href="libswd_8c.html#ad4f88acc646c06e6e81fbde8117c21af" title="LibSWD initialization routine.">swd_init</a>();
   <span class="keywordflow">if</span> (swdctx==NULL) <span class="keywordflow">return</span> -1;
   <span class="comment">//we might need to pass external driver structure to swd_drv* functions </span>
   <span class="comment">//swdctx-&gt;driver-&gt;device=...</span>
   res=<a class="code" href="libswd_8c.html#a6758b95d2adfbfb9b95198f9b0b5462c" title="Macro: Reset target DAP, select SW-DP, read out IDCODE.">swd_dap_detect</a>(swdctx, <a class="code" href="libswd_8h.html#a35ca817603eaed3d5ce753c37a1db070a56d19aa6e805b636d0c679df01a83bf1" title="Queue commands then flush the queue.">SWD_OPERATION_EXECUTE</a>, &amp;idcode);
   <span class="keywordflow">if</span> (res&lt;0){
    printf(<span class="stringliteral">&quot;ERROR: %s\n&quot;</span>, swd_error_string(res));
    <span class="keywordflow">return</span> res;
   } <span class="keywordflow">else</span> printf(<span class="stringliteral">&quot;IDCODE: 0x%X (%s)\n&quot;</span>, *idcode, <a class="code" href="libswd_8c.html#a271c7fcdfe6cf9d5177bd2fca4e02497" title="Generates string containing binary data of an integer value.">swd_bin32_string</a>(*idcode));
   <a class="code" href="libswd_8c.html#a94b02a9cf4b72e2e76d6a9a34f34f96f" title="De-initialize selected swd context and its command queue.">swd_deinit</a>(swdctx);
   <span class="keywordflow">return</span> idcode;
  }
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Apr 2 2011 04:00:00 for Serial Wire Debug Open Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
